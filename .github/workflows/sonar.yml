name: Sonar Scan

on:
  push:
    branches: [ci]
  pull_request:
    branches: [master, development, "*_baseline"]

jobs:
  build-and-collect-coverage:
    name: Build & Collect Coverage
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper SonarQube analysis

      - name: Run tests with coverage (ignore failures)
        continue-on-error: true
        run: |
          xcodebuild -quiet test \
            -project Split.xcodeproj \
            -scheme Split \
            -parallel-testing-enabled YES \
            -destination 'platform=iOS Simulator,OS=17.2,name=iPhone 15' \
            -enableCodeCoverage YES \
            -resultBundlePath build/Logs/Test/TestResults.xcresult \
            -derivedDataPath build

      - name: Export coverage to LCOV
        run: |
          set -euo pipefail

          mkdir -p coverage

          # Ensure DerivedData is at ./build (from test step)
          echo "ðŸ“ Listing profdata files under build/"
          find build -name "*.profdata" || true

          # Get the first .profdata file in the derived data path
          PROFRAW=$(find build -type f -name "*.profdata" | head -n 1 || true)
          if [[ -z "$PROFRAW" ]]; then
            echo "âŒ Error: No .profdata file found under build/"
            exit 1
          fi

          echo "âœ… Found profdata: $PROFRAW"

          # Find Split.framework binary in Debug config
          BINARY=$(find build -type f -path "*/Build/Products/Debug-iphonesimulator/Split.framework/Split" | head -n 1 || true)
          if [[ -z "$BINARY" ]]; then
            echo "âŒ Error: Split binary not found under Debug-iphonesimulator/"
            find build -name "Split"  # Debugging output
            exit 1
          fi

          echo "âœ… Found binary: $BINARY"

          # Export coverage to LCOV format
          xcrun llvm-cov export \
            -instr-profile "$PROFRAW" \
            -arch x86_64 \
            "$BINARY" \
            -format=lcov > coverage/coverage.lcov

          echo "âœ… coverage.lcov generated at: coverage/coverage.lcov"

      - name: Check coverage file
        run: |
          echo "ðŸ“Š Checking coverage file contents..."

          # Check if file exists and has content
          if [ ! -f coverage/coverage.lcov ]; then
            echo "âŒ Error: coverage.lcov file does not exist"
            exit 1
          fi

          # Check file size
          FILE_SIZE=$(stat -f%z coverage/coverage.lcov)
          echo "ðŸ“ File size: $FILE_SIZE bytes"

          if [ "$FILE_SIZE" -lt 100 ]; then
            echo "âš ï¸ Warning: coverage file is suspiciously small ($FILE_SIZE bytes)"
            cat coverage/coverage.lcov
          else
            echo "âœ… Coverage file size looks good"
            # Show first few lines to verify format
            head -n 10 coverage/coverage.lcov
          fi

          # Check if file contains expected LCOV format elements
          if ! grep -q "SF:" coverage/coverage.lcov; then
            echo "âŒ Error: coverage file does not contain source file entries (SF:)"
            exit 1
          fi

          if ! grep -q "DA:" coverage/coverage.lcov; then
            echo "âŒ Error: coverage file does not contain line coverage data (DA:)"
            exit 1
          fi

          echo "âœ… Coverage file format validation passed"

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: coverage/coverage.lcov

  sonar:
    name: Run SonarQube Scan
    runs-on: ubuntu-latest
    needs: build-and-collect-coverage
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper SonarQube analysis

      - name: Download coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage
          path: .

      - name: Verify coverage file
        run: |
          echo "ðŸ“Š Verifying coverage file after download..."
          
          # Check multiple possible locations
          if [ -f "coverage.lcov" ]; then
            echo "âœ… Found coverage file at ./coverage.lcov"
            mkdir -p coverage
            cp coverage.lcov coverage/coverage.lcov
            COVERAGE_PATH="coverage/coverage.lcov"
          elif [ -f "coverage/coverage.lcov" ]; then
            echo "âœ… Found coverage file at ./coverage/coverage.lcov"
            COVERAGE_PATH="coverage/coverage.lcov"
          else
            echo "âŒ Coverage file not found in expected locations"
            echo "ðŸ“‚ Current directory contents:"
            ls -la
            echo "ðŸ“‚ Looking for any .lcov files:"
            find . -name "*.lcov" || echo "No .lcov files found"
            exit 1
          fi
          
          # Check file size
          FILE_SIZE=$(stat -c%s "$COVERAGE_PATH")
          echo "ðŸ“ File size: $FILE_SIZE bytes"
          
          if [ "$FILE_SIZE" -lt 100 ]; then
            echo "âš ï¸ Warning: coverage file is suspiciously small ($FILE_SIZE bytes)"
            cat "$COVERAGE_PATH"
            exit 1
          fi
          
          # Verify file format
          if ! grep -q "SF:" "$COVERAGE_PATH"; then
            echo "âŒ Error: coverage file does not contain source file entries (SF:)"
            exit 1
          fi
          
          if ! grep -q "DA:" "$COVERAGE_PATH"; then
            echo "âŒ Error: coverage file does not contain line coverage data (DA:)"
            exit 1
          fi
          
          echo "âœ… Coverage file format validation passed"
          
          # Check path format in coverage file
          echo "ðŸ“ƒ Sample of source file paths in coverage file:"
          grep -m 5 "SF:" "$COVERAGE_PATH"
          
          # Create a modified version with relative paths for SonarQube
          echo "ðŸ“ Creating modified coverage file with relative paths..."
          REPO_NAME="ios-client"
          
          # Create the coverage file directly in the root directory with the exact name SonarQube expects
          # Use a more robust path transformation that handles different path formats and ensures proper format for Swift
          sed -E "s|SF:/Users/runner/work/${REPO_NAME}/${REPO_NAME}/|SF:|g; s|SF:/Users/runner/work/${REPO_NAME}/|SF:|g" "$COVERAGE_PATH" > "coverage.lcov.temp"
          
          # Process the LCOV file to ensure it has the format SonarQube expects for Swift
          # This ensures each file entry has proper structure with FNF/FNH (functions found/hit) and LF/LH (lines found/hit)
          echo "ðŸ“Š Processing LCOV file to ensure SonarQube compatibility..."
          
          awk '
          BEGIN { print "TN:" }
          /SF:/ { 
            if (file) { 
              if (!fnf) print "FNF:0"; 
              if (!fnh) print "FNH:0"; 
              if (!lf) print "LF:0"; 
              if (!lh) print "LH:0"; 
              print "end_of_record"; 
            }
            file=$0; print file; fnf=0; fnh=0; lf=0; lh=0; 
          }
          /FNF:/ { fnf=1; print }
          /FNH:/ { fnh=1; print }
          /LF:/ { lf=1; print }
          /LH:/ { lh=1; print }
          !/^(SF:|FNF:|FNH:|LF:|LH:|end_of_record|TN:)/ { print }
          /end_of_record/ { 
            if (!fnf) print "FNF:0"; 
            if (!fnh) print "FNH:0"; 
            if (!lf) print "LF:0"; 
            if (!lh) print "LH:0"; 
            print "end_of_record"; 
            file=""; fnf=0; fnh=0; lf=0; lh=0; 
          }
          END { 
            if (file) { 
              if (!fnf) print "FNF:0"; 
              if (!fnh) print "FNH:0"; 
              if (!lf) print "LF:0"; 
              if (!lh) print "LH:0"; 
              print "end_of_record"; 
            }
          }
          ' coverage.lcov.temp > coverage.lcov
          
          # Check if we have any source files that don't match the project structure
          echo "ðŸ“ƒ Checking for problematic paths in coverage file..."
          grep "SF:/" "coverage.lcov" | head -n 10 || echo "No problematic paths found"
          
          echo "ðŸ“ƒ Sample of modified source file paths:"
          grep -m 5 "SF:" "coverage.lcov"
          
          # Verify the file exists in the root directory
          echo "ðŸ“‚ Files in current directory:"
          ls -la *.lcov || echo "No .lcov files found in root directory"
          
          # Count entries in coverage file
          echo "ðŸ“Š Coverage statistics:"
          echo "Total lines in coverage file: $(wc -l < coverage.lcov)"
          echo "Number of source files: $(grep -c "SF:" coverage.lcov)"
          echo "Number of line coverage entries: $(grep -c "DA:" coverage.lcov)"
          
          # Create a debug version with more complete information
          echo "ðŸ“ Creating debug version of coverage file..."
          cp coverage.lcov coverage.debug.lcov
          
          # Show the first complete file coverage entry for debugging
          echo "ðŸ“„ Sample complete coverage entry:"
          awk '/SF:/{p=1;print;next} /end_of_record/{p=0;print;print "---"} p{print}' coverage.lcov | head -n 30

      - name: Run SonarQube scan
        uses: sonarsource/sonarqube-scan-action@v5
        with:
          projectBaseDir: .
          args: >
            -Dsonar.projectKey=splitio_ios-client
            -Dsonar.projectName=${{ github.event.repository.name }}
            -Dsonar.c.file.suffixes=-
            -Dsonar.cpp.file.suffixes=-
            -Dsonar.objc.file.suffixes=-
            -Dsonar.swift.coverage.reportPaths=coverage.lcov
            -Dsonar.verbose=true
            -Dsonar.sources=Split
            -Dsonar.exclusions=**/Tests/**,**/*.generated.swift
            -Dsonar.coverage.exclusions=**/Tests/**,**/*.generated.swift
        env:
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONARQUBE_HOST }}
